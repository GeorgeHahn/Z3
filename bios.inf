Constant ScrWidth     = 240;
Constant ScrHeight    = 320;
Constant BufferHeight = 640;
Constant LineStride   = 30;
Constant LineStrideW  = 15;
Constant TextHeight   = 10;
Constant KeyboardStartLine		= 241;
Constant KeyboardTextSpacing	= 20;
Constant KeyboardSepSpacing		= 5;

Constant DictionaryOff = 8;

Constant cAbbrev      = 0;
Constant cEncodO      = 2;
Constant cEncodB      = 4;
Constant cScrenX	  = 8;
Constant cScrenY	  = 10;
Constant cFontO		  = 12;
Constant cFontB		  = 14;
Constant cBitMpW	  = 16;
Constant cScroll	  = 18;
Constant cTextO		  = 20;
Constant cTextB		  = 22;
Constant cTextSep	  = 24;
Constant MaxTextSize  = $400;

Constant contextW     = $D800; ! $1B000

! Code should start at $1E580
! Font + Encoding data is directly before
! Game must be smaller than $1E000 (120Kb) to fit in BIOS

! BitMap buffer is at the top of the high RAM (18.75Kb)
! Scratch buffer is below the bitmap and is 1Kb
! Context structure is just below that
! Bottom of high RAM are the stacks growing up

[Main;
! Used as a table to pick out addresses of functions
SysInit();
SysPrint();
SysPrintChar();
SysPrintNum();
SysRead();
];

[DecodeText
inputO inputW !inputs
outputO outputB encodingO encodingB alpha charWord c char charOut; !temps

outputO=cTextO==>contextW;
outputB=cTextB==>contextW;
encodingO=cEncodO==>contextW;
encodingB=cEncodB==>contextW;
alpha=0;
do
{
	charWord = inputO-->inputW;
	for (c=0: c<3: c++)
	{
		if (c==0) char=(charWord&$7c00)/1024;
		else if (c==1) char=(charWord&$3e0)/32;
		else char=charWord&31;

		charOut=-1;
		if (alpha<=2 && char<=5)
		{
			if (char==0)
			{
				charOut=' ';
				alpha=0;
			}
			else
			{
				if (char>=4)
					alpha=char-3;
				else
					alpha=char+2;
			}
		}
		else if (char==6 && alpha==2)
		{
			alpha=6;
		}
		else
		{
			if (alpha<=2)
			{
				charOut=encodingO->(encodingB+26*alpha+char-6);
				alpha=0;
			}
			else if (alpha<=5)
			{
				cTextB==>contextW=outputB;
				DecodeText(0, (cAbbrev==>contextW)-->(32*(alpha-3)+char));
				outputB=cTextB==>contextW;
				alpha=0;
			}
			else if (alpha==6)
			{
				alpha=32+char*32;
			}
			else
			{
				charOut=(alpha-32)|char;
				alpha=0;
			}
		}
		if (charOut>=0)
		{
			outputO=>outputB=charOut;
			outputB++;
		}
	}
	inputW++;
}
until (charWord<0);
outputO=>outputB=0;

cTextB==>contextW=outputB;
];

[TextToConsole
textO textB
fontO fontB bitmapW char ptr a b w x y checkWrap firstLine;

x=cScrenX==>contextW;
y=cScrenY==>contextW;
fontO=cFontO==>contextW;
fontB=cFontB==>contextW;
bitmapW=cBitMpW==>contextW;
char=textO=>textB;
if (x~=0)
	checkWrap=1;
firstLine=1;
while (char)
{
	if (char<=32)
	{
		checkWrap=1;
	}
	else if (checkWrap)
	{
		w=x;
		ptr=textB;
		while (textO=>ptr>32)
		{
			w=w+(fontO->(fontB+(textO=>ptr)*TextHeight));
			ptr++;
		}
		if (w>ScrWidth)
		{
			x=ScrWidth+1;
		}
		checkWrap=0;
	}
	ptr=fontB+char*TextHeight;
	w=fontO->ptr;
	if (x+w>ScrWidth || char==10)
	{
		y=y+TextHeight;
		if (y>BufferHeight)
			y=0;
		a=y*LineStride;
		b=LineStride*5;
		while (b)
		{
			a==>bitmapW=0;
			a=a+2;
			b--;
		}
		x=0;
		firstLine=0;
	}
	if (x~=0 || char>32 || firstLine)
	{
		if (cTextSep==>contextW==0 || char==124)
		{
			a=7-(x&7);
			b=2;
			while (a)
			{
				b=b*2;
				a--;
			}
			a=x/8+y*LineStride;
			for (char=0: char<9: char++)
			{
				ptr++;
				a==>bitmapW=(a==>bitmapW)|((fontO->ptr)*b);
				a=a+LineStride;
			}
		}
		x=x+w;
	}
	textB++;
	char=textO=>textB;
}
cScrenX==>contextW=x;
cScrenY==>contextW=y;
];

[UpdateScreen
ptr size sizeW; !temps
	@write_reg $ffff $ff14;	! Set colour 0
	@write_reg $ffff $49c2; ! Set colour 1
	@write_reg 32 0;
	@write_reg 33 0;
	ptr=(cBitMpW==>contextW)+(LineStrideW*(cScroll==>contextW));
	sizeW=LineStride*KeyboardStartLine;
	if ((cScroll==>contextW) + KeyboardStartLine > BufferHeight)
	{
		size=BufferHeight-(cScroll==>contextW);
		sizeW=LineStride*size;
		@blit1 ptr sizeW;
		ptr=cBitMpW==>contextW;
		@write_reg 32 0;
		@write_reg 33 size;
		sizeW=LineStride*(KeyboardStartLine-size);
	}
	@blit1 ptr sizeW;
];

[InitScreenRegs;
@write_reg $0000 $0000; ! Setting primes the screen for data
@write_reg $0001 $0100;
@write_reg $0002 $0700;
@write_reg $0003 $1030;
@write_reg $0008 $0302;
@write_reg $0009 $0000;
@write_reg $000A $0008;
@write_reg $0010 $0790;
@write_reg $0011 $0005;
@write_reg $0012 $0000;
@write_reg $0013 $0000;
@write_reg $0010 $12B0;
@write_reg $0011 $0007;
@write_reg $0012 $008C;
@write_reg $0013 $1700;
@write_reg $0029 $0022;
@write_reg $0030 $0000;
@write_reg $0031 $0505;
@write_reg $0032 $0205;
@write_reg $0035 $0206;
@write_reg $0036 $0408;
@write_reg $0037 $0000;
@write_reg $0038 $0504;
@write_reg $0039 $0206;
@write_reg $003C $0206;
@write_reg $003D $0408;
@write_reg $0050 $0000;
@write_reg $0051 $00EF;
@write_reg $0052 $0000;
@write_reg $0053 $013F;
@write_reg $0060 $A700;
@write_reg $0061 $0001;
@write_reg $0090 $0033;
@write_reg $0081 $0000;
@write_reg $0082 $0000;
@write_reg $0083 $013F;
];

[InitContext;
cAbbrev==>contextW=$18-->0;
cEncodO==>contextW=$FFFF; !1E500
cEncodB==>contextW=$E501;
cScrenX==>contextW=0;
cScrenY==>contextW=0;
cFontO ==>contextW=$FFFF; ! $1E000
cFontB ==>contextW=$E001;
cBitMpW==>contextW=-BufferHeight*LineStrideW;
cScroll==>contextW=0;
cTextO==>contextW=cBitMpW==>contextW;
cTextB==>contextW=cBitMpW==>contextW-MaxTextSize;
cTextSep==>contextW=0;
];

[SysPrint
printO printW;
DecodeText(printO&1, printW);
if (printO&2) ! Doing print_ret so need to add a newline
{
	printO=cTextO==>contextW;
	printW=cTextB==>contextW;
	printO->printW=10;
	printW++;
	printO->printW=0;
}
cTextB==>contextW=(cBitMpW==>contextW-MaxTextSize); ! reset buffer as Decode modifies it
TextToConsole(cTextO==>contextW, cTextB==>contextW);
rtrue;
];

[SysPrintChar
char
textO textB;
textO=cTextO==>contextW;
textB=cTextB==>contextW;
textO=>textB=char;
textB++;
textO=>textB=0;
TextToConsole(textO, textB-1);
rtrue;
];

[SysPrintNum
num
digit writeStarted demon;
demon=10000;
if (num<0)
{
	SysPrintChar('-');
	demon=-demon;
}
while (1)
{
	digit=num/demon;
	if (digit<0) ! Not sure why I need to do this but fixes -32678
		digit=-digit;
	if (digit>0 || writeStarted || demon==1 || demon==-1)
	{
		SysPrintChar('0'+digit);
		writeStarted=1;
		if (demon==1 || demon==-1)
			break;
	}
	num=num-digit*demon;
	demon=demon/10;	
}
rtrue;
];

[DrawKeyboard
size ptr line i shifted;
! Use print system to make keyboard bitmaps then blit to screen
for (i=0: i<2; i++)
{
	cTextSep==>contextW=i;
	if (shifted)
	{
		@print "   Q   |  W   |  E   |  R   |   T   |  Y   |  U   |   I   |  O   |  P^";
		@print "        A  |   S   |  D   |  F   |  G   |  H   |   J   |  K   |   L^";
		@print "            Z  |   X   |  C   |  V   |  B   |  N   |  M   |   ,^";
	}
	else
	{
		@print "    q  |   w  |   e   |  r   |   t   |   y  |   u   |   i   |  o   |   p^";
		@print "        a  |   s   |  d   |   f   |   g  |   h   |  j   |   k   |   l^";
		@print "            z  |   x   |  c   |   v  |   b   |  n   |  m   |   ,^";
	}
	@print "          Shift          |        Space         |         Enter^";
}
cTextSep==>contextW=0;
@write_reg $ffff $22b0;
@write_reg $ffff $d75f;
@write_reg 32 0;
size=LineStride*TextHeight;
ptr=cBitMpW==>contextW;
line=KeyboardStartLine+KeyboardSepSpacing;
for (i=0: i<4: i=i+1)
{
	@write_reg 33 line;
	@blit1 ptr size;
	ptr=ptr+TextHeight*LineStrideW;
	line=line+KeyboardTextSpacing;
}
size=LineStride*KeyboardSepSpacing;
line=KeyboardStartLine;
for (i=0: i<4: i=i+1)
{
	@write_reg 33 line;
	@blit1 ptr size;
	line=line+TextHeight+KeyboardSepSpacing-1;
	@write_reg 33 line;
	@blit1 ptr size;
	line=line+KeyboardSepSpacing+1;
	ptr=ptr+TextHeight*LineStrideW;
}
@write_reg $ffff $d75f;
line=KeyboardStartLine-1;
size=LineStride;
for (i=0: i<4: i=i+1)
{
	@write_reg 33 line;
	@blit1 ptr size;
	line=line+TextHeight+2*KeyboardSepSpacing;
}
ptr=cBitMpW==>contextW;
for (i=0: i<LineStride*TextHeight*8: i=i+2)
{
	i==>ptr=0;
}
cScrenY==>contextW=0;
];

[SysInit;
InitContext();
InitScreenRegs();
DrawKeyboard();
];

[FindInDictionary
text parse
encodingO encodingB textO textB count limit i a c;

encodingO=cEncodO==>contextW;
textO=cTextO==>contextW;
textB=cTextB==>contextW;
limit=textB+6;

i=6;
while (i)
{
	i--;
	textO=>(textB+i)=5;
}

count=parse->2;
text=text+parse->3;

while (count && textB<limit)
{
	c=text->0;
	text++;
	count--;
	if (c==32)
	{
		textO=>textB=0;
		textB++;
	}
	else
	{
		i=0;
		a=3;
		encodingB=cEncodB==>contextW;
		while (c~=encodingO->encodingB)
		{
			encodingB++;
			i++;
			if (i==26)
			{
				if (a==5)
					break;
				a++;
				i=0;
			}
		}
		if (a>3)
		{
			textO=>textB=a;
			textB++;
		}
		if (i==26)
		{
			textO=>textB=6;
			textB++;
			textO=>textB=(c/32)&$1F;
			textB++;
			textO=>textB=c&$1F;
			textB++;
		}
		else
		{
			textO=>textB=6+i;
			textB++;
		}
	}
}

textB=cTextB==>contextW;
a=textO=>(textB  )*1024+textO=>(textB+1)*32+textO=>(textB+2);
c=textO=>(textB+3)*1024+textO=>(textB+4)*32+textO=>(textB+5);
c=c|$8000;

i=DictionaryOff-->0;
parse-->0=0;
i=i+i->0+1;
limit=i->0;
i++;
count=i-->0;
i=i+2;
while (count)
{
	if (i-->0==a && i-->1==c)
	{
		parse-->0=i;
		break;
	}
	i=i+limit;
	count--;
}
];

[SysRead
parse text
count i c sep dict readingWord parse0;

if (26==>contextW==0)
{
	text->0=9;
	text->1=109;
	text->2=111;
	text->3=112;
	text->4=32;
	text->5=102;
	text->6=108;
	text->7=111;
	text->8=111;
	text->9=114;
	text->10=0;
}
else
{
	text->0=1;
	text->1=105;
	text->2=0;
}
TextToConsole(text, 1);
SysPrintChar(10);

parse0=parse;
parse++;
parse++;

parse0->1=0;
count=text->0;
i=1;
while (count)
{
	c=text->i;
	if (c==32)
	{
		sep=-1;
	}
	else
	{
		dict=DictionaryOff-->0;
		sep=dict->0;
		while (sep)
		{
			if (c==dict->sep)
				break;
			sep--;
		}
	}
	if (readingWord)
	{
		if (sep)
		{
			parse0->1=parse0->1+1;
			parse->2=i-parse->3;
			FindInDictionary(text, parse);
			parse=parse+4;
			readingWord=0;
			if (sep>0)
			{
				parse->3=i;
				readingWord=1;
			}
		}
	}
	else if (sep>=0)
	{
		parse->3=i;
		readingWord=1;
	}
	count--;
	i++;
}
if (readingWord)
{
	parse0->1=parse0->1+1;
	parse->2=i-parse->3;
	FindInDictionary(text, parse);
}
UpdateScreen();
@write_reg $0007 $0133; ! Turn on the screen
if (26==>contextW==2)
	quit;
26==>contextW=26==>contextW+1;
];

