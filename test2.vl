module boss(clk, data, address, writeEnable, forceDynamicRead, forceStaticRead, dataOut, printEnable);

input clk;
input [7:0] data;

output [16:0] address;
output writeEnable;
output forceDynamicRead;
output forceStaticRead;
output [7:0] dataOut;
output printEnable;

reg [16:0] address;
reg writeEnable;
reg forceDynamicRead;
reg forceStaticRead;
reg [7:0] dataOut;
reg printEnable;

`define OPER_LARGE 2'b00
`define OPER_SMALL 2'b01
`define OPER_VARI  2'b10
`define OPER_OMIT  2'b11

`define STATE_FETCH_OP		0
`define STATE_READ_TYPES	1
`define STATE_READ_OPERS	2
`define STATE_READ_STORE	3
`define STATE_READ_BRANCH	4
`define STATE_DO_OP			5
`define STATE_READ_FUNCTION	6
`define STATE_CALL_FUNCTION	7
`define STATE_RET_FUNCTION	8
`define STATE_STORE_REGISTER 9
`define STATE_PRINT			10
`define STATE_RESET 		11
`define STATE_HALT			12
`define STATE_PRINT_CHAR	13

`define OP_0	2'b00
`define OP_1	2'b01
`define OP_2	2'b10
`define OP_VAR	2'b11

`define OP0_RTRUE	'h0
`define OP0_RFALSE	'h1
`define OP0_PRINT	'h2
`define OP0_PRINTRET 'h3
`define OP0_NOP		'h4
`define OP0_SAVE	'h5
`define OP0_RESTORE	'h6
`define OP0_RESTART	'h7
`define OP0_RETPOP	'h8
`define OP0_POP		'h9
`define OP0_QUIT	'hA
`define OP0_NEWLINE	'hB
`define OP0_SHOWSTATUS	'hC
`define OP0_VERIFY	'hD

`define OP1_JZ		'h0
`define OP1_GETSIBLING 'h1
`define OP1_GETCHILD 'h2
`define OP1_GETPARENT 'h3
`define OP1_GETPROPLEN 'h4
`define OP1_INC		'h5
`define OP1_DEC		'h6
`define OP1_PRINTADDR 'h7
`define OP1_REMOVEOBJ 'h9
`define OP1_PRINTOBJ 'hA
`define OP1_RET		'hB
`define OP1_JUMP	'hC
`define OP1_PRINTPADDR 'hD
`define OP1_LOAD 'hE
`define OP1_NOT 'hF

`define OP2_JE		'h1
`define OP2_JL		'h2
`define OP2_JG		'h3
`define OP2_DEC_CHK	'h4
`define OP2_INC_CHK	'h5
`define OP2_JIN		'h6
`define OP2_TEST	'h7
`define OP2_OR		'h8
`define OP2_AND		'h9
`define OP2_TESTATTR 'hA
`define OP2_SETATTR 'hB
`define OP2_CLEARATTR 'hC
`define OP2_STORE	'hD
`define OP2_INSERTOBJ 'hE
`define OP2_LOADW	'hF
`define OP2_LOADB	'h10
`define OP2_GETPROP	'h11
`define OP2_GETPROPADDR	'h12
`define OP2_GETNEXTPROP	'h13
`define OP2_ADD		'h14
`define OP2_SUB		'h15
`define OP2_MUL		'h16
`define OP2_DIV		'h17
`define OP2_MOD		'h18

`define OPVAR_CALL   'h0
`define OPVAR_STOREW 'h1
`define OPVAR_STOREB 'h2
`define OPVAR_PUTPROP 'h3
`define OPVAR_SREAD  'h4
`define OPVAR_PRINTCHAR 'h5
`define OPVAR_PRINTNUM 'h6
`define OPVAR_RANDOM 'h7
`define OPVAR_PUSH 'h8
`define OPVAR_PULL 'h9

`define PRINTEFFECT_FETCH		0
`define PRINTEFFECT_FETCHAFTER	1
`define PRINTEFFECT_RET1		2
`define PRINTEFFECT_ABBREVRET	3

reg [3:0] state;

reg [16:0] pc;
reg [16:0] curPC;
reg [16:0] globalsAddress;
reg [16:0] objectTable;

reg readHigh;

reg [4:0] op;
reg [1:0] operNum;
reg [0:1] operTypes [4:0];
reg [15:0] operand [3:0];
reg [2:0] operandIdx;
reg [13:0] branch;
reg [7:0] store;
reg negate;

reg delayedBranch;
reg [7:0] delayedRegNum;
reg [15:0] delayedValue;

reg [15:0] returnValue;

reg [6:0] opsToRead;
reg [6:0] currentLocal; 
reg [17:0] csStack;
reg [17:0] stackAddress;

reg [16:0] temp;
reg [3:0] phase;

initial
begin
	state=`STATE_RESET;
	readHigh=0;
	pc=0;
	globalsAddress='hF000;
	operTypes[0]=`OPER_OMIT;
	operTypes[1]=`OPER_OMIT;
	operTypes[2]=`OPER_OMIT;
	operTypes[3]=`OPER_OMIT;
	operTypes[4]=`OPER_OMIT;
	opsToRead=0;
	forceDynamicRead=0;
	writeEnable=0;
	printEnable<=0;
	phase<=0;
end

task StoreB;
	begin
		case (phase)
			0: begin address<=operand[0]+operand[1]; writeEnable<=1; dataOut<=operand[2][7:0]; phase<=phase+1; end
			1: begin address<=pc; writeEnable<=0; state<=`STATE_FETCH_OP; phase<=0; end
		endcase
	end
endtask

task StoreW;
	begin
		case (phase)
			0: begin address<=operand[0]+operand[1]+0; writeEnable<=1; dataOut<=operand[2][15:8]; phase<=phase+1; end
			1: begin address<=address+1; dataOut<=operand[2][7:0]; phase<=phase+1; end
			2: begin address<=pc; writeEnable<=0; state<=`STATE_FETCH_OP; phase<=0; end
		endcase
	end
endtask

task StoreRegisterAndBranch;
	input [7:0] regNum;
	input [15:0] value;
	input doBranch;
	begin
		state<=`STATE_STORE_REGISTER;
		delayedRegNum<=regNum;
		delayedValue<=value;
		delayedBranch<=doBranch;
		phase<=0;
	end
endtask

task StoreResult;
	input [15:0] result;
	begin
		StoreRegisterAndBranch(store, result, negate); // negate means won't branch
	end
endtask

task StoreResultAndBranch;
	input [15:0] result;
	input doBranch;
	begin
		StoreRegisterAndBranch(store, result, doBranch);
	end
endtask

task ReturnFunction;
	input [15:0] value;
	begin
		returnValue<=value;
		phase<=0;
		state<=`STATE_RET_FUNCTION;
	end
endtask

task CallFunction;
	begin
		if (operand[0]==0) begin
			ReturnFunction(0);
		end else begin
			phase<=0;
			state<=`STATE_CALL_FUNCTION;
		end
	end
endtask

task DoBranch;
	input result;
	begin
		if ((!result)==negate) begin
			if (branch==0) begin
				ReturnFunction(0);
			end else if (branch==1) begin
				ReturnFunction(1);
			end else begin
				pc<=$signed(pc)+$signed(branch)-2;
				address<=$signed(pc)+$signed(branch)-2;
				state<=`STATE_FETCH_OP;
			end
		end else begin
			address<=pc;
			state<=`STATE_FETCH_OP;
		end
	end
endtask

task LoadAndStore;
	input [16:0] loadAddress;
	input [7:0]  storeLocation;
	input		 word;
	begin
		if (phase==0) begin
			address<=loadAddress;
			phase<=phase+1;
		end else if (phase==1) begin
			if (word) begin
				temp[7:0]<=data;
				address<=loadAddress+1;
				phase<=phase+1;
			end else begin
				StoreResult(data);
			end
		end else begin
			StoreResult((temp[7:0]<<8)|data);
		end
	end
endtask

function [16:0] GetObjectAddr;
	input [7:0] object;
	begin
		GetObjectAddr=objectTable+2*31+9*(object-1);
	end
endfunction

task TestAttr;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+(operand[1]/8); phase<=phase+1; end
			1: DoBranch(data[7-(operand[1]&7)]);
		endcase
	end
endtask

task SetAttr;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+(operand[1]/8); phase<=phase+1; end
			1: begin dataOut<=data|(1<<(operand[1]&7)); writeEnable<=1; phase<=phase+1; end
			2: begin writeEnable<=0; address<=pc; state=`STATE_FETCH_OP; end
		endcase
	end
endtask

task ClearAttr;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+(operand[1]/8); phase<=phase+1; end
			1: begin dataOut<=data&(~(1<<(operand[1]&7))); writeEnable<=1; phase<=phase+1; end
			2: begin writeEnable<=0; address<=pc; state=`STATE_FETCH_OP; end
		endcase
	end
endtask

task JumpIfParent;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4; phase<=phase+1; end
			1: DoBranch(operand[1]==data);
		endcase
	end
endtask

task GetRelative;
	input [1:0] offset;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4+offset; phase<=phase+1; end
			1: StoreResultAndBranch(data, data==0);
		endcase
	end
endtask

task GetParent;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4; phase<=phase+1; end
			1: StoreResult(data);
		endcase
	end
endtask

task FindProp;
	begin
		case (phase[2:0])
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin temp[16]<=0; temp[15:8]<=data; temp[7:0]<=0; address<=address+1; phase<=phase+1; end
			2: begin temp[7:0]<=data; address<=temp|data; phase<=phase+1; end
			3: begin temp<=temp+2*data+1; address<=temp+2*data+1; phase<=phase+1; end
			4: begin
				if (data==0) begin	// end of search (get default)
					temp<=objectTable+2*operand[1];
					address<=objectTable+2*operand[1];
					phase<=phase+1;
				end else if (data[4:0]==operand[1]) begin // found property
					temp<=temp+1;
					address<=temp+1;
					if (data[7:5]==0) // only 1 byte
						phase<=6;
					else
						phase<=5;
				end else begin // skip over data
					temp<=temp+data[7:5]+2;
					address<=temp+data[7:5]+2;
				end
		   	end
			5: begin temp[7:0]<=data; address<=temp+1; phase<=phase+1; end
			6: begin StoreResult((temp[7:0]<<8)|data); end
		endcase
	end
endtask

task SetProp;
	begin
		case (phase[2:0])
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin temp[16]<=0; temp[15:8]<=data; temp[7:0]<=0; address<=address+1; phase<=phase+1; end
			2: begin temp[7:0]<=data; address<=temp|data; phase<=phase+1; end
			3: begin temp<=temp+2*data+1; address<=temp+2*data+1; phase<=phase+1; end
			4: begin
				if (data==0) begin // end of search
					state<=`STATE_HALT;
				end else if (data[4:0]==operand[1]) begin // found property
					temp<=temp+1;
					if (data[7:5]==0) begin // only 1 byte
						dataOut<=operand[2][7:0];
						phase<=6;
						address<=temp+1;
						writeEnable<=1;
					end else begin
						dataOut<=operand[2][15:8];
						phase<=5;
						address<=temp+1;
						writeEnable<=1;
					end
				end else begin // skip over data
					temp<=temp+data[7:5]+2;
					address<=temp+data[7:5]+2;
				end
			end
			5: begin dataOut<=operand[1][7:0]; address<=temp+1; phase<=phase+1; end
			6: begin state<=`STATE_FETCH_OP; address<=pc; writeEnable<=0; end
		endcase
	end
endtask

task FindPropAddrLen;
	input findAddress;
	begin
		case (phase[2:0])
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin temp[16]<=0; temp[15:8]<=data; temp[7:0]<=0; address<=address+1; phase<=phase+1; end
			2: begin temp[7:0]<=data; address<=temp|data; phase<=phase+1; end
			3: begin temp<=temp+2*data+1; address<=temp+2*data+1; phase<=phase+1; end
			4: begin
				if (data==0) begin	// end of search
					StoreResult(0);
				end else if (data[4:0]==operand[1]) begin // found property
					StoreResult(findAddress?(temp+1):(data[7:5]+1));
				end else begin // skip over data
					temp<=temp+data[7:5]+2;
					address<=temp+data[7:5]+2;
				end
		   	end
		endcase
	end
endtask

task FindNextProp;
	begin
		case (phase[2:0])
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin temp[16]<=0; temp[15:8]<=data; temp[7:0]<=0; address<=address+1; phase<=phase+1; end
			2: begin temp[7:0]<=data; address<=temp|data; phase<=phase+1; end
			3: begin temp<=temp+2*data+1; address<=temp+2*data+1; phase<=phase+1; end
			4: begin
				if (operand[1]==0 || data[4:0]==operand[1])
					StoreResult(data[4:0]);
				else if (data==0) begin	// end of search
					state<=`STATE_HALT;
				end else begin // skip over data
					temp<=temp+data[7:5]+2;
					address<=temp+data[7:5]+2;
				end
		   	end
		endcase
	end
endtask

task Pull;
	input return;
	begin
		case (phase)
			0: begin
				address<=stackAddress-2;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			1: begin
				stackAddress<=stackAddress-2;
				temp[15:8]<=data;
				temp[7:0]<=0;
				address<=stackAddress-1;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			2: begin
				forceDynamicRead<=0;
				if (return)
					ReturnFunction(temp[15:0]|data);
				else
					StoreRegisterAndBranch(operand[0], temp[15:0]|data, negate);
			end
		endcase

	end
endtask

task Print;
	input [16:0] addr;
	input [7:0] effect;
	begin
		temp<=addr;
		state<=`STATE_PRINT;
		returnValue<=effect;
		delayedBranch<=0;
		phase<=0;
	end
endtask

task PrintObj;
	begin
		case (phase[1:0])
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin returnValue[7:0]<=data; address<=address+1; phase<=phase+1; end
			default: Print((returnValue<<8)+data+1, `PRINTEFFECT_FETCH);
		endcase
	end
endtask

task Load;
	begin
		case (phase)
			0: begin
				if (operand[0]>=16) begin
					temp<=globalsAddress+2*(operand[0]-16);
					address<=globalsAddress+2*(operand[0]-16);
				end else if (operand[0]==0) begin
					temp<=stackAddress-2;
					address<=stackAddress-2;
					stackAddress<=stackAddress-2;
					forceDynamicRead<=1;
				end else begin
					temp<=csStack+7+2*(operand[0]-1);
					address<=csStack+7+2*(operand[0]-1);
					forceDynamicRead<=1;
				end
				phase<=phase+1;
			end
			1: begin
				operand[1][7:0]<=data;
				address<=temp+1;
				phase<=phase+1;
			end
			2: begin
				forceDynamicRead<=0;
				StoreResult((operand[1][7:0]<<8)|data);
			end
		endcase
	end
endtask

task RemoveObject;
	input andInsert;
	begin
		case (phase[3:0])
			0: begin address<=GetObjectAddr(operand[0])+4; /*obj.parent*/ phase<=phase+1; end
			1: begin
				if (data==0) begin
					state<=`STATE_FETCH_OP;
					address<=pc;
				end else begin
					temp[15:8]<=data;
					writeEnable<=1;
					dataOut<=0;
					phase<=phase+1;
				end
			end
			2: begin writeEnable<=0; address<=address+1; /*obj.sibling*/ phase<=phase+1; end
			3: begin temp[7:0]<=data; writeEnable<=1; dataOut<=0; phase<=phase+1; end
			4: begin writeEnable<=0; address<=address+1; /*parent.child*/ phase<=phase+1; end
			5: begin
				if (data==operand[0]) begin // found object
					dataOut<=temp[7:0];
					writeEnable<=1;
					phase<=andInsert?phase+1:10;
				end else begin
					address<=GetObjectAddr(data)+5; /*follow sibling*/
				end
			end

			6: begin address<=GetObjectAddr(operand[1])+6; phase<=phase+1; end
			7: begin temp[7:0]<=data; writeEnable<=1; dataOut<=operand[0]; phase<=phase+1; end
			8: begin address<=GetObjectAddr(operand[0])+4; dataOut<=operand[1][7:0]; phase<=phase+1; end
			9: begin address<=address+1; dataOut<=temp[7:0]; phase<=phase+1; end
			10: begin
				writeEnable<=0;
				state<=`STATE_FETCH_OP;
				address<=pc;
			end
		endcase
	end
endtask

task DoOp;
	input nextState;
	begin
		case (operNum)
			`OP_0: begin
				if (phase==0)
					$display("Doing op0:%d Store:%h Branch:%h/%d", op, operand[0], store, branch, negate);
				case (op)
					`OP0_RTRUE: ReturnFunction(1);
					`OP0_RFALSE: ReturnFunction(0);
					`OP0_PRINT: Print(pc, `PRINTEFFECT_FETCHAFTER);
					`OP0_PRINTRET: Print(pc, `PRINTEFFECT_RET1);
					`OP0_NOP: state<=`STATE_FETCH_OP;
					`OP0_SAVE,`OP0_RESTORE: DoBranch(0);
					`OP0_RESTART: state<=`STATE_RESET;
					`OP0_RETPOP: Pull(1);
					`OP0_POP: begin stackAddress<=stackAddress-2; state<=`STATE_FETCH_OP; end
					`OP0_QUIT: state<=`STATE_HALT;
					`OP0_NEWLINE: begin printEnable<=1; dataOut<=10; state<=`STATE_PRINT_CHAR; end
					`OP0_SHOWSTATUS: state<=`STATE_FETCH_OP;
					`OP0_VERIFY: DoBranch(1);
					default: state<=`STATE_HALT;
				endcase
			end
			`OP_1: begin
				if (phase==0)
					$display("Doing op1:%d Operands:%h Store:%h Branch:%h/%d", op, operand[0], store, branch, negate);
				case (op)
					`OP1_JZ: DoBranch(operand[0]==0);
					`OP1_GETSIBLING: GetRelative(1);
					`OP1_GETCHILD: GetRelative(2);
					`OP1_GETPARENT: GetParent();
					`OP1_GETPROPLEN: FindPropAddrLen(0);
					`OP1_INC: StoreResult(operand[0]+1);
					`OP1_DEC: StoreResult(operand[0]-1);
					`OP1_PRINTADDR: Print(operand[0], `PRINTEFFECT_FETCH); 
					`OP1_REMOVEOBJ: RemoveObject(0);
					`OP1_PRINTOBJ: PrintObj();
					`OP1_RET: ReturnFunction(operand[0]);
					`OP1_JUMP: begin pc<=$signed(pc)+$signed(operand[0])-2; address<=$signed(pc)+$signed(operand[0])-2; state<=`STATE_FETCH_OP; end
					`OP1_PRINTPADDR: Print(2*operand[0], `PRINTEFFECT_FETCH); 
					`OP1_LOAD: Load();
					`OP1_NOT: StoreResult(~operand[0]);
					default: state<=`STATE_HALT;
				endcase
			end
			`OP_2: begin
				if (phase==0)
					$display("Doing op2:%d Operands:%h %h Store:%h Branch:%h/%d/%h", op, operand[0], operand[1], store, branch, negate, $signed(pc)+$signed(branch-2));
				case (op)
					`OP2_JE: DoBranch(operand[0]==operand[1]);
					`OP2_JL: DoBranch($signed(operand[0])<$signed(operand[1]));
					`OP2_JG: DoBranch($signed(operand[0])>$signed(operand[1]));
					`OP2_INC_CHK: StoreResultAndBranch(operand[0]+1, operand[0]+1==operand[1]);
					`OP2_DEC_CHK: StoreResultAndBranch(operand[0]-1, operand[0]-1==operand[1]);
					`OP2_JIN: JumpIfParent();
					`OP2_TEST: DoBranch((operand[0]&operand[1])==operand[1]);
					`OP2_OR: StoreResult(operand[0]|operand[1]);
					`OP2_AND: StoreResult(operand[0]&operand[1]);
					`OP2_TESTATTR: TestAttr();
					`OP2_SETATTR: SetAttr();
					`OP2_CLEARATTR: ClearAttr();
					`OP2_STORE: StoreRegisterAndBranch(operand[0], operand[1], negate);
					`OP2_INSERTOBJ: RemoveObject(1);
					`OP2_LOADW: LoadAndStore(operand[0]+2*operand[1], store, 1);
					`OP2_LOADB: LoadAndStore(operand[0]+operand[1], store, 0);
					`OP2_GETPROP: FindProp();
					`OP2_GETPROPADDR: FindPropAddrLen(1);
					`OP2_GETNEXTPROP: FindNextProp();
					`OP2_ADD: StoreResult($signed(operand[0])+$signed(operand[1]));
					`OP2_SUB: StoreResult($signed(operand[0])-$signed(operand[1]));
					`OP2_MUL: StoreResult($signed(operand[0])*$signed(operand[1]));
					`OP2_DIV: StoreResult($signed(operand[0])/$signed(operand[1]));
					//`OP2_MOD: StoreResult($signed(operand[0])%$signed(operand[1]));
					default: state<=`STATE_HALT;
				endcase
			end
			`OP_VAR: begin
				if (phase==0)
					$display("Doing opvar:%d Operands:%h %h %h %h Store:%h Branch:%h/%d/%h", op, operand[0], operand[1], operand[2], operand[3], store, branch, negate, $signed(pc)+$signed(branch-2));
				case (op)
					`OPVAR_CALL: CallFunction();
					`OPVAR_STOREW: StoreW();
					`OPVAR_STOREB: StoreB();
					`OPVAR_PUTPROP: SetProp();
					`OPVAR_SREAD: begin $display("SREAD"); state<=`STATE_HALT; end
					`OPVAR_PRINTCHAR: begin printEnable<=1; dataOut<=operand[0]; state<=`STATE_PRINT_CHAR; end
					`OPVAR_PRINTNUM: begin $display("PRINTNUM:%d", $signed(operand[0])); state<=`STATE_FETCH_OP; end
					`OPVAR_RANDOM: StoreResult(0); // FIXME: Need to implement properly 
					`OPVAR_PUSH: StoreRegisterAndBranch(0, operand[0], negate);
					`OPVAR_PULL: Pull(0);
					default: state<=`STATE_HALT;
				endcase
			end
		endcase
	end
endtask

reg [1:0] alphabet;
reg [1:0] long;
			
task DoPrint;
	input [4:0] char;
	begin
		if (delayedBranch) begin
			store[4:0]<=char;
			operand[1]<=phase+1;
			delayedBranch<=0;
			phase<=6;
		end else if (long==1) begin
			operand[3][4:0]=char;
			long<=long+1;
		end else if (long==2) begin
			printEnable<=1;
			dataOut<=(operand[3][4:0]<<5)|char;
			long<=0;
		end else begin
			phase<=phase+1;
			if (char==0) begin
				printEnable<=1;
				dataOut<=32;
			end else if (char==4 || char==5) begin
				printEnable<=0;
				alphabet=char-3;
			end else if (char>=6) begin
				printEnable<=!(alphabet==2 && char==6);
				if (alphabet==2) begin
					case (char)
						6: long<=1;
						7: dataOut<=10;
						8,9,10,11,12,13,14,15,16,17: dataOut<=char-8+48;
						18: dataOut<=46;
						19: dataOut<=44;
						20: dataOut<=33;
						21: dataOut<=63;
						22: dataOut<=95;
						23: dataOut<=35;
						24: dataOut<=39;
						25: dataOut<=34;
						26: dataOut<=47;
						27: dataOut<=92;
						28: dataOut<=45;
						29: dataOut<=58;
						30: dataOut<=40;
						31: dataOut<=41;
					endcase
				end else begin
					dataOut<=char-6+((alphabet==0)?97:65);
				end
				alphabet<=0;
			end else begin
				printEnable<=0;
				store[7:5]<=(char-1);
				delayedBranch<=1;
			end
		end
	end
endtask

always @ (posedge clk)
begin
	case(state)
		`STATE_RESET: begin
			case (phase)
				0: begin forceStaticRead<=1; address<='h6; phase<=phase+1; end
				1: begin address<='h7; phase<=phase+1; pc[15:8]<=data; pc[16]<=0; end
				2: begin address<='hA; phase<=phase+1; pc[7:0]<=data; end
				3: begin address<='hB; phase<=phase+1; objectTable[15:8]<=data; objectTable[16]<=0; end
				4: begin address<='hC; phase<=phase+1; objectTable[7:0]<=data; end
				5: begin address<='hD; phase<=phase+1; globalsAddress[15:8]<=data; globalsAddress[16]<=0; end
				6: begin temp<=0; address<=0; phase<=phase+1; globalsAddress[7:0]<=data; end
				7: begin dataOut<=data; writeEnable<=1; phase<=8; end
				8: begin writeEnable<=0; address<=address+1; if (address[15:0]=='hffff) phase<=9; else phase<=7; end
				9: begin
					address<=pc; phase<=0; forceStaticRead<=0; state<=`STATE_FETCH_OP;
					stackAddress<=64*1024;
					csStack<=65*1024;
				end
			endcase
		end
		`STATE_CALL_FUNCTION: begin
			case (phase)
				0: begin address<=csStack+phase; writeEnable<=1; dataOut<=pc[16]; phase<=phase+1; end
				1: begin address<=csStack+phase; dataOut<=pc[15:8]; phase<=phase+1; end
				2: begin address<=csStack+phase; dataOut<=pc[7:0]; phase<=phase+1; end
				3: begin address<=csStack+phase; dataOut<=stackAddress[16]; phase<=phase+1; end
				4: begin address<=csStack+phase; dataOut<=stackAddress[15:8]; phase<=phase+1; end
				5: begin address<=csStack+phase; dataOut<=stackAddress[7:0]; phase<=phase+1; end
				6: begin address<=csStack+phase; dataOut<=store; phase<=phase+1; end
				7: begin
					csStack<=csStack+37;
					pc<=2*operand[0];
					address<=2*operand[0];
					state<=`STATE_READ_FUNCTION;
					writeEnable<=0;
					phase<=0;
				end
			endcase
		end
		`STATE_RET_FUNCTION: begin
			case (phase)
				0: begin csStack<=csStack-37; address<=csStack-37+phase; forceDynamicRead<=1; phase<=phase+1; end
				1: begin pc[16]=data[0]; address<=csStack+phase; phase<=phase+1; end
				2: begin pc[15:8]=data; address<=csStack+phase; phase<=phase+1; end
				3: begin pc[7:0]=data; address<=csStack+phase; phase<=phase+1; end
				4: begin stackAddress[16]=data[0]; address<=csStack+phase; phase<=phase+1; end
				5: begin stackAddress[15:8]=data; address<=csStack+phase; phase<=phase+1; end
				6: begin stackAddress[7:0]=data; address<=csStack+phase; phase<=phase+1; end
				7: begin
					forceDynamicRead<=0;
					StoreRegisterAndBranch(data, returnValue, negate);
				end
			endcase
		end
		`STATE_READ_FUNCTION: begin
			case (phase)
				0: begin
					if (data==0) begin
						state<=`STATE_FETCH_OP;
					end else begin
						opsToRead<=4*data-1;
						phase<=phase+1;
					end
					currentLocal<=0;
					pc<=pc+1;
					address<=pc+1;
				end
				1: begin
					if (opsToRead&1) begin
						dataOut<=data;
						address<=csStack+7+currentLocal;
						writeEnable<=1;
						currentLocal<=currentLocal+1;
					end else begin
						pc<=pc+1;
						address<=pc+1;
						writeEnable<=0;
					end
					if (opsToRead==1) begin
						phase<=phase+1;
						currentLocal<=0;
					end
					opsToRead<=opsToRead-1;
				end
				2: begin
					if (operTypes[(currentLocal>>1)+1]==`OPER_OMIT) begin
						state<=`STATE_FETCH_OP;
						writeEnable<=0;
						pc<=pc+1;
						address<=pc+1;
						phase<=0;
					end else begin
						dataOut<=currentLocal[0]?operand[(currentLocal>>1)+1][7:0]:operand[(currentLocal>>1)+1][15:8];
						writeEnable<=1;
						address<=csStack+7+currentLocal;
					end
					currentLocal<=currentLocal+1;
				end
			endcase
		end
		`STATE_FETCH_OP: begin
			curPC<=pc;
			phase<=0;
			$display("Fetching op at %h", pc);
			case (data[7:6])
				2'b10: begin
					// short form
					op[4:0]<=data[3:0];
					operTypes[0]<=data[5:4];
					operTypes[1]<=`OPER_OMIT;
					operTypes[2]<=`OPER_OMIT;
					operTypes[3]<=`OPER_OMIT;
					if (data[5:4]==2'b11) begin
						operNum[1:0]<=`OP_0;
						case (data[3:0])
							'h05,'h06,'h0D,'h0F: state<=`STATE_READ_BRANCH;
							default: state<=`STATE_DO_OP;
						endcase
					end else begin
						operNum[1:0]<=`OP_1;
						state<=`STATE_READ_OPERS;
					end
				end
				2'b11: begin
					// variable form
					op[4:0]<=data[4:0];
					operNum[1:0]<=(data[5]?`OP_VAR:`OP_2);
					state<=`STATE_READ_TYPES;
				end
				default: begin
					// long form
					op[4:0]<=data[4:0];
					operNum[1:0]<=`OP_2;
					operTypes[0]<=(data[6] ? `OPER_VARI : `OPER_SMALL);
					operTypes[1]<=(data[5] ? `OPER_VARI : `OPER_SMALL);
					operTypes[2]<=`OPER_OMIT;
					operTypes[3]<=`OPER_OMIT;
					state<=`STATE_READ_OPERS;
				end
			endcase
			operandIdx<=0;
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_TYPES: begin
			operTypes[0]<=data[7:6];
			operTypes[1]<=data[5:4];
			operTypes[2]<=data[3:2];
			operTypes[3]<=data[1:0];
			state<=`STATE_READ_OPERS;
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_OPERS: begin
			case (operTypes[operandIdx])
				`OPER_SMALL: begin
					if (operandIdx==0 && ((operNum==`OP_1 && (op==`OP1_INC || op==`OP1_DEC)) || (operNum==`OP_2 && (op==`OP2_INC_CHK || op==`OP2_DEC_CHK)))) begin
						store<=data;
						operTypes[operandIdx]<=`OPER_VARI;
						address<=pc;
					end else begin
						operand[operandIdx]<=data[7:0];
						pc<=pc+1;
						address<=pc+1;
						operandIdx<=operandIdx+1;
					end
				end
				`OPER_LARGE: begin
					if (!readHigh) begin
						operand[operandIdx][15:8]<=data[7:0];
						readHigh<=1;
					end else begin
						operand[operandIdx][7:0]<=data[7:0];
						operandIdx<=operandIdx+1;
						readHigh<=0;
					end
					pc<=pc+1;
					address<=pc+1;
				end
				`OPER_VARI: begin
					case (phase)
						0: begin
							if (data>=16) begin
								temp<=globalsAddress+2*(data-16);
								address<=globalsAddress+2*(data-16);
							end else if (data==0) begin
								temp<=stackAddress-2;
								address<=stackAddress-2;
								stackAddress<=stackAddress-2;
								forceDynamicRead<=1;
							end else begin
								temp<=csStack+7+2*(data-1);
								address<=csStack+7+2*(data-1);
								forceDynamicRead<=1;
							end
							pc<=pc+1;		
							phase<=phase+1;
						end
						1: begin
							operand[operandIdx]<=(data<<8);
							address<=temp+1;
							phase<=phase+1;
						end
						2: begin
							forceDynamicRead<=0;
							operand[operandIdx]<=operand[operandIdx]|data;
							address<=pc;
							operandIdx<=operandIdx+1;
							phase<=0;
						end
					endcase
				end
				`OPER_OMIT: begin
					case (operNum)
						`OP_1: begin
							case (op[4:0])
								'h01,'h02,'h03,'h04,'h08,'h0E,'h0F: state<=`STATE_READ_STORE;
								'h00: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						`OP_2: begin
							case (op[4:0])
								'h08,'h09,'h0F,'h10,'h11,'h12,'h13,'h14,'h15,'h16,'h17,'h18,'h19: state<=`STATE_READ_STORE;
								'h01,'h02,'h03,'h04,'h05,'h06,'h07,'h0A: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						`OP_VAR: begin
							case (op[4:0])
								'h00,'h07,'h0C,'h16,'h17,'h18: state<=`STATE_READ_STORE;
								'h1F: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						default: state<=`STATE_DO_OP;
					endcase
					address<=pc;
				end
			endcase
		end
		`STATE_READ_STORE: begin
			store<=data;
			case (operNum)
				`OP_1: begin
					case (op[4:0])
						'h01,'h02: state<=`STATE_READ_BRANCH;
						default: state<=`STATE_DO_OP;
					endcase
				end
				`OP_VAR: begin
					case (op[4:0])
						'h17: state<=`STATE_READ_BRANCH;
						default: state<=`STATE_DO_OP;
					endcase
				end
				default: state<=`STATE_DO_OP;
			endcase
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_BRANCH: begin
			if (!readHigh) begin
				if (data[6]) begin
					branch<=data[5:0];
					negate<=!data[7];
					state<=`STATE_DO_OP;
				end else begin
					branch[13:8]<=data[5:0];
					negate<=!data[7];
					readHigh<=1;
				end
			end else begin
				branch[7:0]<=data;
				readHigh<=0;
				state<=`STATE_DO_OP;
			end
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_DO_OP: begin
			DoOp(`STATE_FETCH_OP);
		end
		`STATE_STORE_REGISTER: begin
			case (phase)
				0: begin
					if (delayedRegNum>=16) begin
						temp<=globalsAddress+2*(delayedRegNum-16);
						address<=globalsAddress+2*(delayedRegNum-16);
					end else if (delayedRegNum==0) begin
						temp<=stackAddress;
						address<=stackAddress;
						stackAddress<=stackAddress+2;
					end else begin
						temp<=csStack+7+2*(delayedRegNum-1);
						address<=csStack+7+2*(delayedRegNum-1);
					end
					dataOut<=delayedValue[15:8];
					writeEnable<=1;
					phase<=phase+1;
				end
				1: begin
					dataOut<=delayedValue[7:0];
					address<=temp+1;
					writeEnable<=1;
					phase<=phase+1;
				end
				2: begin
					DoBranch(delayedBranch);
					writeEnable<=0;
					phase<=0;
				end
			endcase
		end
		`STATE_PRINT: begin
			case (phase)
				0: begin delayedValue[15:8]<=data; address<=address+1; phase<=phase+1; end
				1: begin delayedValue[7:0] <=data; address<=address+1; phase<=phase+1; end
				2,3,4: begin DoPrint(delayedValue[14:10]); delayedValue[14:5]<=delayedValue[9:0]; end
				5: begin
					printEnable<=0;
					if (delayedValue[15]) begin
						alphabet<=0;
						long<=0;
						case (returnValue[1:0])
							`PRINTEFFECT_FETCH: begin
								address<=pc;
								state<=`STATE_FETCH_OP;
							end
							`PRINTEFFECT_FETCHAFTER: begin
								pc<=address;
								state<=`STATE_FETCH_OP;
							end
							`PRINTEFFECT_RET1: begin
								ReturnFunction(1);
							end
							`PRINTEFFECT_ABBREVRET: begin
								address<=temp;
								delayedValue<=operand[0];
								phase<=operand[1];
								returnValue[1:0]<=returnValue[3:2]; 
							end
						endcase
					end else begin
						phase<=0;
					end
				end
				// branch to abbrev
				6: begin
					address<='h18;
					phase<=phase+1;
					temp<=address;
					operand[0]<=delayedValue;
					returnValue[3:2]=returnValue[1:0];
					returnValue[1:0]=`PRINTEFFECT_ABBREVRET; 
				end
				7: begin address<=address+1; operand[2][7:0]=data; phase<=phase+1; end
				8: begin address<=(operand[2][7:0]<<8)|data+2*store; phase<=phase+1; end
				9: begin address<=address+1; operand[2][7:0]<=data; phase<=phase+1; end
				10: begin address<=2*((operand[2][7:0]<<8)|data); phase<=0; end
			endcase
		end
		`STATE_PRINT_CHAR: begin
			address<=pc;
			printEnable<=0;
			state<=`STATE_FETCH_OP;
		end
		`STATE_HALT: begin
			$finish;
		end
	endcase
end

endmodule

module main();

reg clk;
reg [7:0] data;
wire [16:0] address;
wire writeEnable;
wire forceDynamicRead;
wire forceStaticRead;
wire [7:0] dataOut;
wire printEnable;

integer file,readData,i;
reg [7:0] mem [128*1024:0];
reg [7:0] dynamicMem [128*1024:0];

initial
begin
	$display("Welcome");
	file=$fopen("Planetfa.z3","rb");
	readData=$fread(mem, file);
	$display("File read:%h %d", file, readData);
	$fclose(file);
	//$monitor("%h %h %h State:%d(%d) Op:%h Num:%h OperType:%h%h%h%h OperIdx:%d Operand:%h %h Store:%h Branch:%h", clk, data, address, b.state, b.phase, b.op, b.operNum, b.operTypes[0], b.operTypes[1], b.operTypes[2], b.operTypes[3], b.operandIdx, b.operand[0], b.operand[1], b.store, b.branch);
	for (i=0; i</*505*/1000000; i=i+1) begin
		clk=1;
		#5 clk=0;
		if (writeEnable) begin
			dynamicMem[address]=dataOut;
		end else if (!forceStaticRead && (address[16]==0 || forceDynamicRead)) begin
			data=dynamicMem[address];
		end else begin
			data=mem[address];
		end
		if (printEnable) begin
			$display("PRINT: %c", dataOut);
		end
		$display("Mem req: %h WE:%d F:%d/%d D:%h DO:%h", address, writeEnable, forceDynamicRead, forceStaticRead, data, dataOut);
	end
	$finish;
end

boss b(clk, data, address, writeEnable, forceDynamicRead, forceStaticRead, dataOut, printEnable);

endmodule

