module boss(clk, data, address, writeEnable, forceDynamicRead, dataOut);

input clk;
input [7:0] data;

output [16:0] address;
output writeEnable;
output forceDynamicRead;
output [7:0] dataOut;

reg [16:0] address;
reg writeEnable;
reg forceDynamicRead;
reg [7:0] dataOut;

reg [3:0] state;
reg [3:0] lastState;

reg [16:0] pc;
reg [16:0] curPC;
reg [16:0] globalsAddress;
reg [16:0] objectTable;

reg readHigh;

reg [4:0] op;
reg [1:0] operNum;
reg [0:1] operTypes [4:0];
reg [15:0] operand [3:0];
reg [2:0] operandIdx;
reg [13:0] branch;
reg [7:0] store;
reg negate;

reg delayedBranch;
reg [7:0] delayedRegNum;
reg [15:0] delayedValue;

reg [15:0] returnValue;

`define OPER_LARGE 2'b00
`define OPER_SMALL 2'b01
`define OPER_VARI  2'b10
`define OPER_OMIT  2'b11

`define STATE_FETCH_OP		0
`define STATE_READ_TYPES	1
`define STATE_READ_OPERS	2
`define STATE_READ_STORE	3
`define STATE_READ_BRANCH	4
`define STATE_DO_OP			5
`define STATE_READ_REG		6
`define STATE_WRITE_MEM		7
`define STATE_READ_FUNCTION	8
`define STATE_CALL_FUNCTION	9
`define STATE_RET_FUNCTION	10
`define STATE_STORE_REGISTER 11

`define OP_0	2'b00
`define OP_1	2'b01
`define OP_2	2'b10
`define OP_VAR	2'b11

`define OP0_RTRUE	'h0
`define OP0_RFALSE	'h1
`define OP0_PRINT	'h2
`define OP0_PRINTRET 'h3
`define OP0_RETPOP	'h8
`define OP0_NEWLINE	'hB

`define OP1_JZ		'h0
`define OP1_GETSIBLING 'h1
`define OP1_GETCHILD 'h2
`define OP1_GETPARENT 'h3
`define OP1_INC		'h5
`define OP1_DEC		'h6
`define OP1_PRINTOBJ 'hA
`define OP1_RET		'hB
`define OP1_JUMP	'hC

`define OP2_JE		'h1
`define OP2_JL		'h2
`define OP2_JG		'h3
`define OP2_DEC_CHK	'h4
`define OP2_INC_CHK	'h5
`define OP2_JIN		'h6
`define OP2_OR		'h8
`define OP2_AND		'h9
`define OP2_TESTATTR 'hA
`define OP2_SETATTR 'hB
`define OP2_STORE	'hD
`define OP2_LOADW	'hF
`define OP2_LOADB	'h10
`define OP2_GETPROP	'h11
`define OP2_ADD		'h14
`define OP2_SUB		'h15
`define OP2_MUL		'h16
`define OP2_DIV		'h17
`define OP2_MOD		'h18

`define OPVAR_CALL   'h0
`define OPVAR_STOREW 'h1
`define OPVAR_STOREB 'h2
`define OPVAR_SREAD  'h4
`define OPVAR_PRINTCHAR 'h5
`define OPVAR_PRINTNUM 'h6
`define OPVAR_RANDOM 'h7
`define OPVAR_PUSH 'h8
`define OPVAR_PULL 'h9

reg [8:0] k;

reg [1:0]  memStack;
reg [16:0] memStackAddress [2:0];
reg [7:0]  memStackValue [2:0];
reg memStackWrite [2:0];

reg [6:0] opsToRead;
reg [6:0] currentLocal; 
reg [17:0] csStack;
reg [17:0] stackAddress;

initial
begin
	state=0;
	readHigh=0;
	pc=0;
	memStack=0;
	memStackWrite[0]=1;
	globalsAddress='hF000;
	operTypes[0]=`OPER_OMIT;
	operTypes[1]=`OPER_OMIT;
	operTypes[2]=`OPER_OMIT;
	operTypes[3]=`OPER_OMIT;
	operTypes[4]=`OPER_OMIT;
	opsToRead=0;
	stackAddress=64*1024;
	csStack=65*1024;
	forceDynamicRead=0;
	writeEnable=0;
end

task DoMemOp16;
	input [16:0] location;
	input [15:0] value;
	input bWrite;
	begin
		$display("MemopW%d: Value:%h Location:%h", bWrite, value, location);
		memStackAddress[0]<=location;
		memStackValue[0]<=value[15:8];
		memStackWrite[0]<=bWrite;
		memStack<=1;
		lastState<=`STATE_FETCH_OP;
		state<=`STATE_WRITE_MEM;
		address<=location+1;
		dataOut<=value[7:0];
		writeEnable<=bWrite;
	end
endtask

task DoMemOp8;
	input [16:0] location;
	input [7:0] value;
	input bWrite;
	begin
		$display("MemopB%d: Value:%h Location:%h", bWrite, value, location);
		memStack<=0;
		lastState<=`STATE_FETCH_OP;
		state<=`STATE_WRITE_MEM;
		address<=location;
		dataOut<=value[7:0];
		writeEnable<=bWrite;
	end
endtask

task StoreRegisterAndBranch;
	input [7:0] regNum;
	input [15:0] value;
	input doBranch;
	begin
		state<=`STATE_STORE_REGISTER;
		delayedRegNum<=regNum;
		delayedValue<=value;
		delayedBranch<=doBranch;
		phase<=0;
	end
endtask

task StoreResult;
	input [15:0] result;
	begin
		StoreRegisterAndBranch(store, result, negate); // negate means won't branch
	end
endtask

task StoreResultAndBranch;
	input [15:0] result;
	input doBranch;
	begin
		StoreRegisterAndBranch(store, result, doBranch);
	end
endtask

task ReturnFunction;
	input [15:0] value;
	begin
		returnValue<=value;
		phase<=0;
		state<=`STATE_RET_FUNCTION;
	end
endtask

task CallFunction;
	begin
		if (operand[0]==0) begin
			ReturnFunction(0);
		end else begin
			phase<=0;
			state<=`STATE_CALL_FUNCTION;
		end
	end
endtask

task DoBranch;
	input result;
	begin
		if ((!result)==negate) begin
			if (branch==0) begin
				ReturnFunction(0);
			end else if (branch==1) begin
				ReturnFunction(1);
			end else begin
				pc<=$signed(pc)+$signed(branch)-2;
				address<=$signed(pc)+$signed(branch)-2;
				state<=`STATE_FETCH_OP;
			end
		end else begin
			address<=pc;
			state<=`STATE_FETCH_OP;
		end
	end
endtask

reg [16:0] temp;
reg [15:0] temp2;
reg [7:0] phase;

task LoadAndStore;
	input [16:0] loadAddress;
	input [7:0]  storeLocation;
	input		 word;
	begin
		if (phase==0) begin
			address<=loadAddress;
			phase<=phase+1;
		end else if (phase==1) begin
			if (word) begin
				temp[15:8]<=data;
				temp[7:0]<=0;
				address<=loadAddress+1;
				phase<=phase+1;
			end else begin
				StoreResult(data);
			end
		end else begin
			StoreResult(temp[15:0]|data);
		end
	end
endtask

function [16:0] GetObjectAddr;
	input [7:0] object;
	begin
		GetObjectAddr=objectTable+2*31+9*(object-1);
	end
endfunction

task TestAttr;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+(operand[1]/8); phase<=phase+1; end
			1: DoBranch(data[7-(operand[1]&7)]);
		endcase
	end
endtask

task SetAttr;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+(operand[1]/8); phase<=phase+1; end
			1: begin dataOut<=data|(1<<(operand[1]&7)); writeEnable<=1; phase<=phase+1; end
			2: begin writeEnable<=0; address<=pc; state=`STATE_FETCH_OP; end
		endcase
	end
endtask

task JumpIfParent;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4; phase<=phase+1; end
			1: DoBranch(operand[1]==data);
		endcase
	end
endtask

task GetRelative;
	input [1:0] offset;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4+offset; phase<=phase+1; end
			1: StoreResultAndBranch(data, data==0);
		endcase
	end
endtask

task GetParent;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+4; phase<=phase+1; end
			1: StoreResult(data);
		endcase
	end
endtask

task FindProp;
	begin
		case (phase)
			0: begin address<=GetObjectAddr(operand[0])+7; phase<=phase+1; end
			1: begin temp[16]<=0; temp[15:8]<=data; temp[7:0]<=0; address<=GetObjectAddr(operand[0])+8; phase<=phase+1; end
			2: begin temp[7:0]<=data; address<=temp|data; phase<=phase+1; end
			3: begin temp<=temp+2*data+1; address<=temp+2*data+1; phase<=phase+1; end
			4: begin
				if (data==0) begin	// end of search (get default)
					temp<=objectTable+2*operand[1];
					address<=objectTable+2*operand[1];
					phase<=phase+1;
				end else if (data[4:0]==operand[1]) begin // found property
					temp<=temp+1;
					address<=temp+1;
					temp2<=0;
					if (data[7:5]==0) // only 1 byte
						phase<=6;
					else
						phase<=5;
				end else begin // skip over data
					temp<=temp+data[7:5]+2;
					address<=temp+data[7:5]+2;
				end
		   	end
			5: begin temp2[15:8]=data; address<=temp+1; phase<=phase+1; end
			6: begin StoreResult(temp2|data); end
		endcase
	end
endtask

task Pull;
	begin
		case (phase)
			0: begin
				address<=stackAddress-2;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			1: begin
				stackAddress<=stackAddress-2;
				temp[15:8]<=data;
				temp[7:0]<=0;
				address<=stackAddress-1;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			2: begin
				forceDynamicRead<=0;
				StoreRegisterAndBranch(operand[0], temp[15:0]|data, negate);
			end
		endcase
	end
endtask

task RetPop;
	begin
		case (phase)
			0: begin
				address<=stackAddress-2;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			1: begin
				stackAddress<=stackAddress-2;
				temp[15:8]<=data;
				temp[7:0]<=0;
				address<=stackAddress-1;
				forceDynamicRead<=1;
				phase<=phase+1;
			end
			2: begin
				forceDynamicRead<=0;
				ReturnFunction(temp[15:0]|data);
			end
		endcase

	end
endtask

task DoOp;
	input nextState;
	begin
		case (operNum)
			`OP_0: begin
				if (phase==0)
					$display("Doing op0:%d Store:%h Branch:%h/%d", op, operand[0], store, branch, negate);
				case (op)
					`OP0_RTRUE: ReturnFunction(1);
					`OP0_RFALSE: ReturnFunction(0);
					`OP0_PRINT: begin
						phase<=1;
						if (pc[0]==curPC[0] || !(data&'h80)) begin
							pc<=pc+1;
							address<=pc+1;
						end else begin
							state<=`STATE_FETCH_OP;
							pc<=pc+2;
							address<=pc+2;
						end
					end
					`OP0_PRINTRET: begin
						// FIXME: Print first
						ReturnFunction(1);
					end
					`OP0_RETPOP: RetPop();
					`OP0_NEWLINE: begin $display("NEWLINE"); state<=`STATE_FETCH_OP; end
					default: begin
						$display("Unknown op");
						state<=`STATE_FETCH_OP;
					end
				endcase
			end
			`OP_1: begin
				if (phase==0)
					$display("Doing op1:%d Operands:%h Store:%h Branch:%h/%d", op, operand[0], store, branch, negate);
				case (op)
					`OP1_JZ: DoBranch(operand[0]==0);
					`OP1_GETSIBLING: GetRelative(1);
					`OP1_GETCHILD: GetRelative(2);
					`OP1_GETPARENT: GetParent();
					`OP1_INC: StoreResult(operand[0]+1);
					`OP1_DEC: StoreResult(operand[0]-1);
					`OP1_PRINTOBJ: begin $display("Print obj %d", operand[0]); state<=`STATE_FETCH_OP; end
					`OP1_RET: ReturnFunction(operand[0]);
					`OP1_JUMP: begin pc<=$signed(pc)+$signed(operand[0])-2; address<=$signed(pc)+$signed(operand[0])-2; state<=`STATE_FETCH_OP; end
					default: begin
						$display("Unknown op");
						state<=`STATE_FETCH_OP;
					end
				endcase
			end
			`OP_2: begin
				if (phase==0)
					$display("Doing op2:%d Operands:%h %h Store:%h Branch:%h/%d/%h", op, operand[0], operand[1], store, branch, negate, $signed(pc)+$signed(branch-2));
				case (op)
					`OP2_JE: DoBranch(operand[0]==operand[1]);
					`OP2_JL: DoBranch($signed(operand[0])<$signed(operand[1]));
					`OP2_JG: DoBranch($signed(operand[0])>$signed(operand[1]));
					`OP2_INC_CHK: StoreResultAndBranch(operand[0]+1, operand[0]+1==operand[1]);
					`OP2_DEC_CHK: StoreResultAndBranch(operand[0]-1, operand[0]-1==operand[1]);
					`OP2_JIN: JumpIfParent();
					`OP2_OR: StoreResult(operand[0]|operand[1]);
					`OP2_AND: StoreResult(operand[0]&operand[1]);
					`OP2_TESTATTR: TestAttr();
					`OP2_SETATTR: SetAttr();
					`OP2_STORE: StoreRegisterAndBranch(operand[0], operand[1], negate);
					`OP2_LOADW: LoadAndStore(operand[0]+2*operand[1], store, 1);
					`OP2_LOADB: LoadAndStore(operand[0]+operand[1], store, 0);
					`OP2_GETPROP: FindProp();
					`OP2_ADD: StoreResult($signed(operand[0])+$signed(operand[1]));
					`OP2_SUB: StoreResult($signed(operand[0])-$signed(operand[1]));
					`OP2_MUL: StoreResult($signed(operand[0])*$signed(operand[1]));
					`OP2_DIV: StoreResult($signed(operand[0])/$signed(operand[1]));
					`OP2_MOD: StoreResult($signed(operand[0])%$signed(operand[1]));
					default: begin
						$display("Unknown op");
						state<=`STATE_FETCH_OP;
					end
				endcase
			end
			`OP_VAR: begin
				if (phase==0)
					$display("Doing opvar:%d Operands:%h %h %h %h Store:%h Branch:%h/%d/%h", op, operand[0], operand[1], operand[2], operand[3], store, branch, negate, $signed(pc)+$signed(branch-2));
				case (op)
					`OPVAR_CALL: CallFunction();
					`OPVAR_STOREW: DoMemOp16(operand[0]+2*operand[1],operand[2], 1);
					`OPVAR_STOREB: DoMemOp8(operand[0]+operand[1],operand[2], 1);
					`OPVAR_SREAD: begin $display("SREAD"); $finish; end
					`OPVAR_PRINTCHAR: begin $display("PRINTCHAR:%d", $signed(operand[0])); state<=`STATE_FETCH_OP; end
					`OPVAR_PRINTNUM: begin $display("PRINTNUM:%d", $signed(operand[0])); state<=`STATE_FETCH_OP; end
					`OPVAR_RANDOM: StoreResult(0); // FIXME
					`OPVAR_PUSH: StoreRegisterAndBranch(0, operand[0], negate);
					`OPVAR_PULL: Pull();
					default: begin
						$display("Unknown op");
						state<=`STATE_FETCH_OP;
					end
				endcase
			end
		endcase
	end
endtask

always @ (posedge clk)
begin
	case(state)
		`STATE_CALL_FUNCTION: begin
			case (phase)
				0: begin address<=csStack+phase; writeEnable<=1; dataOut<=pc[16]; phase<=phase+1; end
				1: begin address<=csStack+phase; writeEnable<=1; dataOut<=pc[15:8]; phase<=phase+1; end
				2: begin address<=csStack+phase; writeEnable<=1; dataOut<=pc[7:0]; phase<=phase+1; end
				3: begin address<=csStack+phase; writeEnable<=1; dataOut<=stackAddress[16]; phase<=phase+1; end
				4: begin address<=csStack+phase; writeEnable<=1; dataOut<=stackAddress[15:8]; phase<=phase+1; end
				5: begin address<=csStack+phase; writeEnable<=1; dataOut<=stackAddress[7:0]; phase<=phase+1; end
				6: begin address<=csStack+phase; writeEnable<=1; dataOut<=store; phase<=phase+1; end
				7: begin
					csStack<=csStack+37;
					pc<=2*operand[0];
					address<=2*operand[0];
					state<=`STATE_READ_FUNCTION;
					writeEnable<=0;
					phase<=0;
				end
			endcase
		end
		`STATE_RET_FUNCTION: begin
			case (phase)
				0: begin csStack<=csStack-37; address<=csStack-37+phase; forceDynamicRead<=1; phase<=phase+1; end
				1: begin pc[16]=data[0]; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				2: begin pc[15:8]=data; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				3: begin pc[7:0]=data; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				4: begin stackAddress[16]=data[0]; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				5: begin stackAddress[15:8]=data; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				6: begin stackAddress[7:0]=data; address<=csStack+phase; forceDynamicRead<=1; phase<=phase+1; end
				7: begin
					forceDynamicRead<=0;
					StoreRegisterAndBranch(data, returnValue, negate);
				end
			endcase
		end
		`STATE_READ_FUNCTION: begin
			case (phase)
				0: begin
					if (data==0) begin
						state<=`STATE_FETCH_OP;
					end else begin
						opsToRead<=4*data-1;
						phase<=phase+1;
					end
					currentLocal<=0;
					pc<=pc+1;
					address<=pc+1;
				end
				1: begin
					if (opsToRead&1) begin
						dataOut<=data;
						address<=csStack+7+currentLocal;
						writeEnable<=1;
						currentLocal<=currentLocal+1;
					end else begin
						pc<=pc+1;
						address<=pc+1;
						writeEnable<=0;
					end
					if (opsToRead==1) begin
						phase<=phase+1;
						currentLocal<=0;
					end
					opsToRead<=opsToRead-1;
				end
				2: begin
					if (operTypes[(currentLocal>>1)+1]==`OPER_OMIT) begin
						state<=`STATE_FETCH_OP;
						writeEnable<=0;
						pc<=pc+1;
						address<=pc+1;
						phase<=0;
					end else begin
						dataOut<=currentLocal[0]?operand[(currentLocal>>1)+1][7:0]:operand[(currentLocal>>1)+1][15:8];
						writeEnable<=1;
						address<=csStack+7+currentLocal;
					end
					currentLocal<=currentLocal+1;
				end
			endcase
		end
		`STATE_FETCH_OP: begin
			curPC<=pc;
			phase<=0;
			$display("Fetching op at %h", pc);
			case (data[7:6])
				2'b10: begin
					// short form
					op[4:0]<=data[3:0];
					operTypes[0]<=data[5:4];
					operTypes[1]<=`OPER_OMIT;
					operTypes[2]<=`OPER_OMIT;
					operTypes[3]<=`OPER_OMIT;
					if (data[5:4]==2'b11) begin
						operNum[1:0]<=`OP_0;
						case (data[3:0])
							'h05,'h06,'h0D,'h0F: state<=`STATE_READ_BRANCH;
							default: state<=`STATE_DO_OP;
						endcase
					end else begin
						operNum[1:0]<=`OP_1;
						state<=`STATE_READ_OPERS;
					end
				end
				2'b11: begin
					// variable form
					op[4:0]<=data[4:0];
					operNum[1:0]<=(data[5]?`OP_VAR:`OP_2);
					state<=`STATE_READ_TYPES;
				end
				default: begin
					// long form
					op[4:0]<=data[4:0];
					operNum[1:0]<=`OP_2;
					operTypes[0]<=(data[6] ? `OPER_VARI : `OPER_SMALL);
					operTypes[1]<=(data[5] ? `OPER_VARI : `OPER_SMALL);
					operTypes[2]<=`OPER_OMIT;
					operTypes[3]<=`OPER_OMIT;
					state<=`STATE_READ_OPERS;
				end
			endcase
			operandIdx<=0;
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_TYPES: begin
			operTypes[0]<=data[7:6];
			operTypes[1]<=data[5:4];
			operTypes[2]<=data[3:2];
			operTypes[3]<=data[1:0];
			state<=`STATE_READ_OPERS;
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_OPERS: begin
			case (operTypes[operandIdx])
				`OPER_SMALL: begin
					if (operandIdx==0 && ((operNum==`OP_1 && (op==`OP1_INC || op==`OP1_DEC)) || (operNum==`OP_2 && (op==`OP2_INC_CHK || op==`OP2_DEC_CHK)))) begin
						store<=data;
						operTypes[operandIdx]<=`OPER_VARI;
						address<=pc;
					end else begin
						operand[operandIdx]<=data[7:0];
						pc<=pc+1;
						address<=pc+1;
						operandIdx<=operandIdx+1;
					end
				end
				`OPER_LARGE: begin
					if (!readHigh) begin
						operand[operandIdx][15:8]<=data[7:0];
						readHigh<=1;
					end else begin
						operand[operandIdx][7:0]<=data[7:0];
						operandIdx<=operandIdx+1;
						readHigh<=0;
					end
					pc<=pc+1;
					address<=pc+1;
				end
				`OPER_VARI: begin
					case (phase)
						0: begin
							if (data>=16) begin
								temp<=globalsAddress+2*(data-16);
								address<=globalsAddress+2*(data-16);
							end else if (data==0) begin
								temp<=stackAddress-2;
								address<=stackAddress-2;
								stackAddress<=stackAddress-2;
								forceDynamicRead<=1;
							end else begin
								temp<=csStack+7+2*(data-1);
								address<=csStack+7+2*(data-1);
								forceDynamicRead<=1;
							end
							pc<=pc+1;		
							phase<=phase+1;
						end
						1: begin
							operand[operandIdx]<=(data<<8);
							address<=temp+1;
							phase<=phase+1;
						end
						2: begin
							forceDynamicRead<=0;
							operand[operandIdx]<=operand[operandIdx]|data;
							address<=pc;
							operandIdx<=operandIdx+1;
							phase<=0;
						end
					endcase
				end
				`OPER_OMIT: begin
					case (operNum)
						`OP_1: begin
							case (op[4:0])
								'h01,'h02,'h03,'h04,'h08,'h0E,'h0F: state<=`STATE_READ_STORE;
								'h00: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						`OP_2: begin
							case (op[4:0])
								'h08,'h09,'h0F,'h10,'h11,'h12,'h13,'h14,'h15,'h16,'h17,'h18,'h19: state<=`STATE_READ_STORE;
								'h01,'h02,'h03,'h04,'h05,'h06,'h07,'h0A: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						`OP_VAR: begin
							case (op[4:0])
								'h00,'h07,'h0C,'h16,'h17,'h18: state<=`STATE_READ_STORE;
								'h1F: state<=`STATE_READ_BRANCH;
								default: state<=`STATE_DO_OP;
							endcase
						end
						default: state<=`STATE_DO_OP;
					endcase
					address<=pc;
				end
			endcase
		end
		`STATE_READ_STORE: begin
			store<=data;
			case (operNum)
				`OP_1: begin
					case (op[4:0])
						'h01,'h02: state<=`STATE_READ_BRANCH;
						default: state<=`STATE_DO_OP;
					endcase
				end
				`OP_VAR: begin
					case (op[4:0])
						'h17: state<=`STATE_READ_BRANCH;
						default: state<=`STATE_DO_OP;
					endcase
				end
				default: state<=`STATE_DO_OP;
			endcase
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_READ_BRANCH: begin
			if (!readHigh) begin
				if (data[6]) begin
					branch<=data[5:0];
					negate<=!data[7];
					state<=`STATE_DO_OP;
				end else begin
					branch[13:8]<=data[5:0];
					negate<=!data[7];
					readHigh<=1;
				end
			end else begin
				branch[7:0]<=data;
				readHigh<=0;
				state<=`STATE_DO_OP;
			end
			pc<=pc+1;
			address<=pc+1;
		end
		`STATE_DO_OP: begin
			DoOp(`STATE_FETCH_OP);
		end
		`STATE_WRITE_MEM: begin
			memStackValue[memStack]<=data;
			if (memStack>0) begin
				address<=memStackAddress[0];
				writeEnable<=memStackWrite[0];
				dataOut<=memStackValue[0];
				memStack<=0;
			end else begin
				writeEnable<=0;
				state<=lastState;
				address<=pc;
			end
		end
		`STATE_STORE_REGISTER: begin
			case (phase)
				0: begin
					if (delayedRegNum>=16) begin
						temp<=globalsAddress+2*(delayedRegNum-16);
						address<=globalsAddress+2*(delayedRegNum-16);
					end else if (delayedRegNum==0) begin
						temp<=stackAddress;
						address<=stackAddress;
						stackAddress<=stackAddress+2;
					end else begin
						temp<=csStack+7+2*(delayedRegNum-1);
						address<=csStack+7+2*(delayedRegNum-1);
					end
					dataOut<=delayedValue[15:8];
					writeEnable<=1;
					phase<=phase+1;
				end
				1: begin
					dataOut<=delayedValue[7:0];
					address<=temp+1;
					writeEnable<=1;
					phase<=phase+1;
				end
				2: begin
					DoBranch(delayedBranch);
					writeEnable<=0;
					phase<=0;
				end
			endcase
		end
	endcase
end

endmodule

module main();

reg clk;
reg [7:0] data;
wire [16:0] address;
wire writeEnable;
wire forceDynamicRead;
wire [7:0] dataOut;

integer file,readData,i;
reg [7:0] mem [128*1024:0];
reg [7:0] dynamicMem [128*1024:0];

initial
begin
	$display("Welcome");
	file=$fopen("Planetfa.z3","rb");
	readData=$fread(mem, file);
	$display("File read:%h %d", file, readData);
	$fclose(file);
	//$monitor("%h %h %h State:%d(%d) Op:%h Num:%h OperType:%h%h%h%h OperIdx:%d Operand:%h %h Store:%h Branch:%h memStack:%h %h %h", clk, data, address, b.state, b.phase, b.op, b.operNum, b.operTypes[0], b.operTypes[1], b.operTypes[2], b.operTypes[3], b.operandIdx, b.operand[0], b.operand[1], b.store, b.branch, b.memStack, b.memStackValue[0], b.memStackValue[1]);
	for (i=0; i<64*1024; i=i+1)
		dynamicMem[i]=mem[i];
	b.pc='h5675;
	b.globalsAddress='h275c;
	b.objectTable='h2c8;
	data=mem[b.pc];
	for (i=0; i</*505*/10000; i=i+1) begin
		clk=1;
		#5 clk=0;
		if (writeEnable) begin
			dynamicMem[address]=dataOut;
		end else if (address[16]==0 || forceDynamicRead) begin
			data=dynamicMem[address];
		end else begin
			data=mem[address];
		end
		$display("Mem req: %h WE:%d FD:%d D:%h DO:%h", address, writeEnable, forceDynamicRead, data, dataOut);
	end
	$finish;
end

boss b(clk, data, address, writeEnable, forceDynamicRead, dataOut);

endmodule

